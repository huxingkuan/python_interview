1. **讲一下事务的四大特性。**

   事务特性ACID：原子性、一致性、隔离性、持久性。

   - **原子性**是指一个事务包含的所有操作是一个整体，要么全部成功，要么全部失败回滚；
   - **一致性**是指一个事务执行之前和执行之后都必须处于一致的状态。比如a账户与b账户共有1000元，两人之间转账之后无论成功与否，他们的账户总和都必须还是1000元；
   - **隔离性**是指多个事务之间相互隔离，不能相互影响。与四个隔离级别有关；
   - **持久性**是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是再数据库系统遇到故障的情况下也不会丢失提交事务的操作。

   > 1. 事务的四大特性中，一致性是目的，其他三大特性是手段，都是为了保证目的正确；
   > 2. 持久性是通过**事务日志**来保证的。日志包括了**重做日志**和**回滚日志**，当我们通过事务对数据进行修改的时候，首先会将数据库的变化信息记录到**重做日志**中，然后再对数据库中对应的行进行修改。这样即使数据库系统崩溃，数据库重启后也能找到没有更新到数据库中的**重做日志**，重新执行，从而使事务具有持久性；

2. **什么是脏写、脏读、不可重复读、幻读？**

   假如有两个事务分别是A和B

   - **脏写：**如果事务A修改了另一个未提交事务B修改过的数据，那就发生了脏写；
   - **脏读：**如果事务A读取了已经被事务B修改了但还没提交的数据，就发生了脏读；
   - **不可重复读：**事务A多次查询数据库中的某行记录却返回了不同的数据，这是因为在查询间隔，事务B对该行记录进行了修改，并且提交了；
   - **幻读：**事务A根据条件查询得到了N条数据，但此时事务B增加了M条符合事务A查询条件的数据并且提交了事务，这样当事务A再次进行查询的时候，其实数据库已经发生了变化，但是事务A却查询不出来新插入的M条数据，因此产生了幻读。

   > 1. 如果事务B是删除了M条符合事务A查询条件的数据，事务A再次查询的时候也没有查询出来这种变化，这种不算是幻读。因为幻读强调的是数据记录的增加。
   > 2. 不可重复读强调的是同一条记录被别的事务修改了导致多次读出来的数据字段有变化；而幻读强调的是数据的记录条数增加了，在多次读取的时候却感知不到。比如明明没有读取到id为4的记录，现在insert一条id为4的记录却返回记录已经存在，则表明发生了幻读，因为记录条数已经增加了，但是事务A没有感知到。

3. **事务的四种隔离级别分别是什么？**

   - **读未提交：**所有事务都可以看到其他未提交事务的执行结果。存在脏读、不可重复读、幻读的问题；
   - **读已提交：**一个事务只能看到其他已提交事务所做的修改。这是大多数数据库系统的默认隔离级别，但MySQL默认隔离级别不是这个。存在不可重复读、幻读问题；
   - **可重复读：**事务A在读到一条数据后，此时事务B对该条数据进行了修改并提交，那么事务A再次读取该条数据，读的还是原来的内容。这是MySQL默认的隔离级别。存在幻读问题。
   - **串行化：**强制事务排序，在一个事务执行期间会直接锁表，禁止其他事务对表进行增删改查操作。所有的并发问题都可以避免，但性能很低下。

4. **生产环境数据库一般用的什么隔离级别？**

   生产环境大多使用读已提交

   - **缘由一：**在可重复读隔离级别下，存在间隙锁，导致出现死锁的几率比读已提交大很多；
   - **缘由二：**在可重读读隔离级别下，条件列未命中索引会锁表，而读已提交只会锁行。

   > 在大部分场景下，不可重复读问题是可以接受的。毕竟数据都已经提交了，读出来本身就没有太大问题。

5. **讲一下redo log。**

   缓冲池可以帮助消除CPU和磁盘之间的鸿沟，`checkpoint`机制可以保证数据的最终落盘，然而`checkpoint`并不是每次变更的时候都会触发，而是master线程隔一段时间去处理一次。所以最坏的情况就是事务提交后，刚写完缓冲池，数据库系统宕机了，那么这段数据就会丢失，无法恢复。因此，我们可以每次提交事务之前把事务所做的修改记录到redo log中，这样即使数据库宕机重启之后还可以根据redo log恢复丢失的事务所提交的数据。

   redo log分为两部分，分别是redo log buffer ，保存在内存中，易丢失，默认是16M，最大值是4096M，最小是1M；redo log file 保存在硬盘中，是持久的。

   redo的整体流程：

   - **第一步：**先将原始数据从磁盘中读取到内存中，修改内存中对应的数据；
   - **第二步：**生成一条redo log并写入redo log buffer中，记录的是数据被修改后的值；
   - **第三步：**当事务提交时，将redo log buffer中的内容刷新到redo log file中，采用追加模式；
   - **第四步：**定期把内存中修改的数据刷新到磁盘中。

   redo log buffer刷盘到redo log file的过程并不是真正的刷到磁盘中，只是刷到了文件系统缓存中，真正的写入磁盘会交给操作系统自己来决定。但是这样的话，如果系统宕机了，那么数据还是会丢失。于是`InnoDB`给出`innodb_flush_log_at_trx_commit`参数，该参数控制事务提交时，redo log buffer的刷盘策略。

   - **设置为0：**表示每次提交事务时不进行刷盘操作，数据库系统默认master线程会每隔1s把redo log buffer刷到文件系统缓存中，可能会丢失1s钟表的数据；
   - **设置为1：**表示每次提交事务时都会刷盘，刷到文件系统缓存中，再立即刷到redo log file中，默认设置，不会丢失数据；
   - **设置为2：**表示每次提交事务时会把redo log buffer内容写到文件系统缓存中，由操作系统自己刷到redo log file中，如果操作系统宕机，会丢失文件系统缓存中的数据。

6. **讲一下数据库的三大范式。**

7. 主键和候选键有什么区别？

8. char和varchar

9. 你怎么看到表格的所有索引

10. like中的%和_分别是什么意思

11. Mysql如何优化distinct

12. 一个表可以使用多少列创建索引

13. 锁的优化策略

14. 索引的底层实现原理和优化

15. 什么情况下索引失效

16. BufferPool缓存和redo日志是如何提升事务性能的

17. redo日志磁盘顺序写机制

18. 查询操作需要使用事务吗

19. 索引下推是什么

20. 联合索引底层数据结构是怎么样的

21. 如何查询慢sql问题

22. 为什么推荐自增行的主键而不是uuid

23. 为什么禁止超过三张表关联查询

24. 

    